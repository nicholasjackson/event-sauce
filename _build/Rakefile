require 'pathname'
require 'docker'
require 'consul/client'

require_relative 'rake-modules/docker'
require_relative 'rake-modules/consul'
require_relative 'rake-modules/helpers'

REGISTRY_URL = ENV['DOCKER_REGISTRY_URL']
REGISTRY_USER = ENV['DOCKER_REGISTRY_USER']
REGISTRY_PASS = ENV['DOCKER_REGISTRY_PASS']
REGISTRY_EMAIL = ENV['DOCKER_REGISTRY_EMAIL']

DOCKER_NAMESPACE = ENV['DOCKER_NAMESPACE']
DOCKER_IMAGE_NAME = 'event-sauce'

GOPATH = ENV["GOPATH"]
GOCMD = "/usr/local/go/bin/go"
GONAMESPACE = 'github.com/nicholasjackson'

ROOTFOLDER = Pathname.new(Dir.pwd).parent

GO_CONTAINER_ARGS = {
	:image => 'golang',
	:binds => [
		"#{GOPATH}/src:/go/src"
	],
	:env => [
		'CGO_ENABLED=0' # needed to build alpine compatible go binaries
	],
	:working_directory => "/go/src/#{GONAMESPACE}/#{DOCKER_IMAGE_NAME}",
	:command => ['/bin/bash']
}

SWAGGER_CONTAINER_ARGS = {
	:image => 'sandcastle/swagger-codegen-docker',
	:binds => [
		"#{ROOTFOLDER}/_build/swagger_spec:/spec",
		"#{ROOTFOLDER}/_build/swagger_spec:/gen",
	],
	:env => [
		'SWAGGER_FILE=swagger.yml',
		'LANGUAGE=html'
	],
	:command => ['/bin/bash']
}

# updates build images for swagger and golang
task :update_images do
	pull_image 'golang:latest'
	pull_image 'sandcastle/swagger-codegen-docker:latest'
end

task :fetch_images do
	pull_image 'golang' unless find_image 'golang:latest'
	pull_image 'sandcastle/swagger-codegen-docker' unless find_image 'sandcastle/swagger-codegen-docker:latest'
end

task :test => [:fetch_images] do
	p "Test Application"
	container = get_container GO_CONTAINER_ARGS

	begin
		# Get go packages
		ret = container.exec(['go','get','-t','-v','./...']) { |stream, chunk| puts "#{stream}: #{chunk}" }
		raise Exception, 'Error running command' unless ret[2] == 0

		# Test application
		ret = container.exec(['go','test','./...']) { |stream, chunk| puts "#{stream}: #{chunk}" }
		raise Exception, 'Error running command' unless ret[2] == 0
	ensure
		container.delete(:force => true)
	end
end

task :docs do
	begin
		container = get_container SWAGGER_CONTAINER_ARGS
		ret = container.exec(['/src/run.sh']) { |stream, chunk| puts "#{stream}: #{chunk}" }
		raise Exception, 'Error running command' unless ret[2] == 0
	ensure
		container.delete(:force => true)
	end
end

task :build => [:fetch_images, :test] do
	p "Build for Linux"
	container = get_container GO_CONTAINER_ARGS

	begin
		# Build go server
		ret = container.exec(['go','build','-a','-installsuffix','cgo','-ldflags','\'-s\'','-o','server']) { |stream, chunk| puts "#{stream}: #{chunk}" }
		raise Exception, 'Error running command' unless ret[2] == 0
	ensure
		container.delete(:force => true)
	end
end

task :build_server => [:build, :docs] do
	p "Building Docker Image:- #{DOCKER_IMAGE_NAME}"

	FileUtils.cp "#{GOPATH}/src/#{GONAMESPACE}/#{DOCKER_IMAGE_NAME}/server", "./dockerfile/#{DOCKER_IMAGE_NAME}/server"
	FileUtils.cp_r "./swagger_spec", "./dockerfile/#{DOCKER_IMAGE_NAME}"

	Docker.options = {:read_timeout => 6200}
	image = Docker::Image.build_from_dir "./dockerfile/#{DOCKER_IMAGE_NAME}", {:t => DOCKER_IMAGE_NAME}
end

task :run do
	begin
    puts `docker-compose -f ./dockercompose/#{DOCKER_IMAGE_NAME}/docker-compose.yml up -d`
    sleep 2
		setConsulVariables get_docker_ip_address, 9500

    sh "docker-compose -f ./dockercompose/#{DOCKER_IMAGE_NAME}/docker-compose.yml logs"
	rescue SystemExit, Interrupt
		sh "docker-compose -f ./dockercompose/#{DOCKER_IMAGE_NAME}/docker-compose.yml stop"
		# remove stopped containers
		sh "echo y | docker-compose -f ./dockercompose/#{DOCKER_IMAGE_NAME}/docker-compose.yml rm"
	end
end

task :build_and_run => [:build_server, :run]

task :docs do
	container = get_container GO_CONTAINER_ARGS

	begin
		# Get go packages
		ret = container.exec(['go','get','github.com/peterhellberg/hiro']) { |stream, chunk| puts "#{stream}: #{chunk}" }
		raise Exception, 'Error running command' unless ret[2] == 0

		# Build docs
		ret = container.exec(['go','run','../../peterhellberg/hiro/main.go',"-input=/api-blueprint/#{DOCKER_IMAGE_NAME}.apib", "-output=/api-blueprint/#{DOCKER_IMAGE_NAME}.html"]) { |stream, chunk| puts "#{stream}: #{chunk}" }
		raise Exception, 'Error running command' unless ret[2] == 0
	ensure
		container.delete(:force => true)
	end
end

task :e2e do
	feature = ARGV.last
	if feature != "e2e"
		feature = "--tags #{feature}"
	else
		feature = ""
	end

	host = get_docker_ip_address

	puts "Running Tests for #{host}"

	ENV['WEB_SERVER_URI'] = "http://#{host}:8001"
	ENV['MONGO_URI'] = "#{host}:27017"
	ENV['EMAIL_SERVER_URI'] = "http://#{host}:1080"

  puts "Running Tests"
	begin
	  puts `docker-compose -f ./dockercompose/#{DOCKER_IMAGE_NAME}/docker-compose.yml up -d`
    sleep 2
		setConsulVariables host, 9500
		self.wait_until_server_running ENV['WEB_SERVER_URI']

		p 'Running Tests'
		puts `cucumber --color #{feature}`
	ensure
    p 'Stopping Application'
		# remove stop running application
		puts `docker-compose -f ./dockercompose/#{DOCKER_IMAGE_NAME}/docker-compose.yml stop`
		# remove stopped containers
		puts `echo y | docker-compose -f ./dockercompose/#{DOCKER_IMAGE_NAME}/docker-compose.yml rm`
	end
end

task :push do
	p "Push image to registry"

	image =  find_image "#{DOCKER_IMAGE_NAME}:latest"
	image.tag('repo' => "#{DOCKER_NAMESPACE}#{DOCKER_IMAGE_NAME}", 'force' => true) unless image.info["RepoTags"].include? "#{DOCKER_NAMESPACE}#{DOCKER_IMAGE_NAME}:latest"

	sh "docker login -u #{REGISTRY_USER} -p #{REGISTRY_PASS} -e #{REGISTRY_EMAIL} #{REGISTRY_URL}"
	sh "docker push #{DOCKER_NAMESPACE}#{DOCKER_IMAGE_NAME}:latest"
end
